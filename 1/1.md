# Serveless框架

## Serveless无服务器架构

并非指没有服务器，而是指应用开发过程中对服务器进行了抽象化的处理，开发人员可以专注构建和运行应用，不需要再管理服务器

开发人员将代码打包到容器中即可部署

部署后无服务器应用即可响应需求，根据需要自动扩展和缩减

公共云（如Tencent 阿里）提供的无服务器产品通常利用事件驱动作为按需计量的付费方式，即当无服务器功能闲置时不会产生任何费用

![image-20250415145431140](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250415145434046.png)

在serveless framework框架中的`serveless.yml`文件中，目前的理解是：可以写除了`service`层的所有功能（如框架版本`frameworkVersion`，云服务提供商`provider`，https接收跨域`cors`等）

在yml文件下方直接就能写function对应的api和https的方法，这样在开发过程中就不需要再注重`router`的路由分组问题，程序员只需要投入到`service function`的编写过程中即可



# TS学习

[reference](https://ts.xcatliu.com/)

**type**是语言的核心：js并没有类型约束，为了开发的严谨性在js中加入类型

```ts
let a: number = 1
a.split(' ')
```

![image-20250415150123044](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250415150123078.png)

因为`number`类型没有`split`方法，所以在编译阶段就会直接报错

弱类型语言：数字＋字符串会隐式类型转换，默认将数字转换为字符串类型并输出字符串

vscode运行ts代码配置

全局配置ts-node

```bash
npm install ts-node -g
```

之后在文件夹中配置tsconfig.json，之前没有配置这个文件导致`typeerror: unknown file extension`

```json
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "CommonJS",
      "rootDir": "./src",
      "outDir": "./dist",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "moduleResolution": "node"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
  }
```

此时需要注意把ts代码存放在子目录的src中，运行结果为

![image-20250415153258548](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250415153258594.png)

![image-20250415153440741](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250415153440797.png)

除了`ts-node`之外，还可以使用`tsc 1.ts`将ts文件翻译为js文件

**使用构造函数`Boolean`创建的对象不是布尔值**

![image-20250415154218250](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250415154218287.png)

返回的是一个`Boolean`对象

```typescript
let a: boolean = true

let consBool: Boolean = new Boolean(1)

let c: boolean = Boolean(1)

console.log(consBool)
console.log(typeof consBool)
console.log(c)
console.log(typeof c)
```

![image-20250415154446541](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250415154446593.png)

因为`boolean`是js的基本类型，而`Boolean`是js中的构造函数

## 任意值

```typescript
let a: any = 7
a = 'abc'
```

未声明类型的变量会被识别为`any`任意值

## 联合类型

```typescript
let a: number | string
a = '1'
a = 1

function getStr(a: number | string): string {
    return a.toString()
}
```

## 接口

typescript中的接口用于：

1. 对类的一部分行为进行抽象
2. 描述``对象的形状``

```typescript
interface Person {
    name: string,
    age: number,
}

let tom: Person = {
    name: 'Tom',
    age: 25,
}
```

使用`interface Person`约束了tom的形状必须和接口`Person`保持一致

接口一般首字母大写，一般在前面加上大写字母I前缀，例如在编写注册接口时：

```typescript
interface ILogin {
    name: string,
    email: string,
    password: string,
    remember?: boolean
}
```

在这里就是用一个可选属性`remember`

接口的任意属性：希望一个接口允许有任意的属性

```typescript
interface Person {
    name: string,
    age?: number,
    [propName: string]: any,
}

let tom: Person = {
    name: 'tom',
    gender: 'male',
}
```

` [propName: string]: any`定义了任意取`string`类型的值

## 数组泛型

```typescript
let a: Array<number> = [1, 2, 3, 4, 5]
```

## 接口表示数组

```typescript
interface NumArray {
    [index: number]: number,
}

let a: NumArray = [1, 2, 3, 4, 5]
```

一般常用来表示类数组

## 函数

```typescript
let mySum: (x: number, y: number) => 
    number = function(x: number, y: number): number {
        return x + y
    }
```

## 字面量类型的声明和不可改变

![image-20250417115306866](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250417115313952.png)

```typescript
let a: 'xyz'
a = '123'
```

此时会报错，相当于`const a = 'xyz'`无法改变

```typescript
const a: string = 'xyz'
a = '123'
```

## string和String的区别

![image-20250417145837351](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250417145837521.png)

```typescript
let str1: string = '123'
let str2: String

str2 = '123'
str2 = new String('2233')
console.log(str2.valueOf())
```

* `string` 官方写法
* `String`是包装器对象，内战占用较大

内置构造函数`Number` `Boolean` `String`都是用于创建对应的包装对象，在内存中占用较大的空间

## 自动装箱

装箱类型`Boolean` `Number` `String` `Symbol`

`String`包括undefined null void以及其拆箱类型`string`

![img](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250418222148330.png)

## Unknown类型

```typescript
let x: unknown

x = 'hello';
let y: string = (x as string).toUpperCase()
console.log(y)
```

在js中的字符串是保持不变的，toUpperCase()返回的是新的大写字符串，并没有改变原来字符串x的值，因此需要有一个接收值y得到大写的字符串

## Never类型

```typescript
let x: never
```

`never`用来限制`function`

返回never的函数不能具有可访问的终结点（函数不能正常结束）

![image-20250422110046568](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250422110053638.png)

```typescript
function demo(): never {
    demo()
}
```

```typescript
function demo(): never {
    throw new Error('程序运行异常')
}
```

* 从来不会有返回值的函数（死循环）
* 一个总是会throw error的函数

![image-20250422110610038](https://cdn.jsdelivr.net/gh/neKoui1/picgo_images/img/20250422110610085.png)

ts会推断出else中的x类型为never,因为没有任何一个值符合else中的逻辑

## void与undefined

void包含undefined，undefined是void能接受的空状态的一种具体形式

## object

* ​	`object`能存储的是非原始类型

  ```typescript
  let a: object
  
  a = {}
  a = {name: '123'}
  a = [1, 2, 3, 4, 5]
  a = function(){}
  a= new String('123')
  class Person{}
  a = new Person()
  ```

## 声明函数类型

```typescript
let count: (a: number, b: number) => number

count = function(a: number, b: number): number {
    return a+b
}
```

```typescript
let count: (a: number, b: number) => number

count = function(a, b){
    return a+b
}
```

```typescript
let count: (a: number, b: number) => number

count = (a, b) => {
    return a+b
}
```

* `ts`在函数声明时的`=>`指明了函数的返回值类型
* `js`中的`=>`是一种定义函数的语法，是具体的函数实现

## 声明数组类型

```typescript
let arr: string[]

arr = ['1', 'a', '122']

let arr2: Array<number>
arr2 = [100, 200]
console.log(arr)
console.log(arr2)
```

## tuple

```typescript
let arr1: [string, number]
arr1 = ['hello', 100]

let arr2: [string, boolean?]
arr2 = ['123', false]
arr2 = ['123']

let arr3: [number, ...string[]] // 任意多个string类型（包括0个）
arr3 = [99]
arr3 = [100, 'a', 'b', 'c', 'd']
console.log(arr3[1])
```

## enum

```typescript
enum Direction {
    up,
    down,
    left,
    right
}
console.log(Direction[0])
console.log(typeof Direction[0])
console.log(Direction)
console.log(Direction['down'])
```

```typescript
const enum Direction {
    up,
    down,
    left,
    right
}

function walk(data: Direction): void {
    switch(data) {
        case Direction.up:
            console.log('up')
            break
        case Direction.down:
            console.log('down')
            break
        default:
            console.log('need check')
    }
}

walk(Direction.up)
walk(Direction.left)
```

## type别名

```typescript
type MyNum = number

let x: MyNum
x = 6
console.log(x)
```

```typescript
// 联合类型
type Status = number | string
type Gender = '男' | '女'

function printStatus(data: Status): void {
    console.log(data)
}

printStatus(404)
printStatus('404')
```

```typescript
// 交叉类型
type Area = {
    height: number,
    width: number,
}

type Address = {
    num: number,
    cell: number,
    room: string,
}

type House = Area & Address
const house: House = {
    height:100,
    width:100,
    num: 100,
    cell: 100,
    room: '1010'
}

console.log(house)
```

使用类型声明限制函数返回值为void时，ts不会严格要求函数返回空

```typescript
type LogFunc = () => void

const f1: LogFunc = function() {
    return 123
}

const f2: LogFunc = () => 123

const f3: LogFunc = function() {
    
}
```

